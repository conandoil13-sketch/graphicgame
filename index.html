<!DOCTYPE html>
<html lang="ko">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Grid Alchemist: The Ultimate Artistic Studio</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://unpkg.com/lucide@latest"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@300;400;700;800&display=swap');

        :root {
            --bg-color: #020205;
            --panel-bg: rgba(10, 10, 18, 0.95);
            --accent-color: #00f2ff;
        }

        body {
            font-family: 'JetBrains Mono', monospace;
            background-color: var(--bg-color);
            color: #e2e8f0;
            margin: 0;
            overflow-x: hidden;
            cursor: crosshair;
        }

        .grid-container {
            display: grid;
            gap: 0;
            background-color: #000;
            line-height: 0;
            image-rendering: pixelated;
        }

        .pixel {
            width: 100%;
            height: 100%;
            transition: background-color 0.4s ease;
        }

        .custom-scrollbar::-webkit-scrollbar {
            width: 4px;
        }

        .custom-scrollbar::-webkit-scrollbar-thumb {
            background: #334155;
            border-radius: 10px;
        }

        .glass {
            background: var(--panel-bg);
            backdrop-filter: blur(25px);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .compiling-active {
            filter: brightness(1.4) saturate(1.3);
            transform: scale(0.998);
        }

        @keyframes pulse-glow {

            0%,
            100% {
                box-shadow: 0 0 20px rgba(0, 242, 255, 0.05);
            }

            50% {
                box-shadow: 0 0 50px rgba(0, 242, 255, 0.15);
            }
        }

        .canvas-glow {
            animation: pulse-glow 5s infinite;
        }

        .dropdown:hover .dropdown-menu {
            display: block;
        }

        .btn-active {
            background-color: var(--accent-color) !important;
            color: #000 !important;
            border-color: var(--accent-color) !important;
        }

        .setup-screen {
            position: fixed;
            inset: 0;
            z-index: 1000;
            background: radial-gradient(circle at center, #0a0a1a 0%, #020205 100%);
            display: flex;
            align-items: center;
            justify-content: center;
            transition: transform 0.8s cubic-bezier(0.85, 0, 0.15, 1);
        }

        .setup-hidden {
            transform: translateY(-100%);
            pointer-events: none;
        }

        .color-slot {
            width: 40px;
            height: 40px;
            border-radius: 4px;
            border: 2px solid rgba(255, 255, 255, 0.1);
            transition: all 0.2s;
            cursor: pointer;
        }

        .color-slot:hover {
            border-color: white;
            transform: translateY(-2px);
        }

        input[type=range] {
            accent-color: var(--accent-color);
            width: 100%;
            height: 6px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 5px;
            appearance: none;
        }

        input[type=range]::-webkit-slider-thumb {
            appearance: none;
            width: 14px;
            height: 14px;
            background: white;
            border-radius: 50%;
            cursor: pointer;
        }

        .slider-label {
            display: flex;
            justify-content: space-between;
            font-size: 10px;
            font-weight: 700;
            text-transform: uppercase;
            margin-bottom: 4px;
            color: #64748b;
        }

        .switch {
            position: relative;
            display: inline-block;
            width: 50px;
            height: 24px;
        }

        .switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }

        .slider-switch {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: rgba(255, 255, 255, 0.1);
            transition: .4s;
            border-radius: 24px;
        }

        .slider-switch:before {
            position: absolute;
            content: "";
            height: 16px;
            width: 16px;
            left: 4px;
            bottom: 4px;
            background-color: white;
            transition: .4s;
            border-radius: 50%;
        }

        input:checked+.slider-switch {
            background-color: var(--accent-color);
        }

        input:checked+.slider-switch:before {
            transform: translateX(26px);
            background-color: black;
        }

        /* HEX Input Styling */
        #hex-input {
            background: transparent;
            border: none;
            outline: none;
            padding: 0;
            width: 100%;
            font-family: inherit;
        }
    </style>
</head>

<body>

    <!-- SETUP SCREEN -->
    <div id="setup-screen" class="setup-screen p-6 overflow-y-auto">
        <div class="max-w-6xl w-full flex flex-col items-center">
            <div class="flex items-center gap-2 text-cyan-400 mb-4">
                <i data-lucide="palette" class="w-6 h-6 animate-pulse"></i>
                <span class="text-xs font-bold tracking-[0.5em] uppercase">Visual DNA Initialization</span>
            </div>
            <h1 class="text-5xl md:text-7xl font-black italic tracking-tighter text-white uppercase text-center mb-10">
                Configure Studio</h1>

            <div class="grid grid-cols-1 lg:grid-cols-12 gap-8 w-full items-stretch">
                <div class="lg:col-span-7 glass p-8 space-y-8 flex flex-col justify-center">
                    <div class="grid grid-cols-1 md:grid-cols-2 gap-10">
                        <div class="space-y-6">
                            <h3
                                class="text-[10px] font-black text-white/40 uppercase tracking-[0.3em] border-l-2 border-cyan-500 pl-3">
                                HSB Control</h3>
                            <div class="space-y-4">
                                <div>
                                    <div class="slider-label"><span>Hue</span><span id="h-val">180°</span></div><input
                                        type="range" id="input-h" min="0" max="360" value="180">
                                </div>
                                <div>
                                    <div class="slider-label"><span>Saturation</span><span id="s-val">100%</span></div>
                                    <input type="range" id="input-s" min="0" max="100" value="100">
                                </div>
                                <div>
                                    <div class="slider-label"><span>Brightness</span><span id="b-val">100%</span></div>
                                    <input type="range" id="input-b" min="0" max="100" value="100">
                                </div>
                            </div>
                        </div>
                        <div class="space-y-6">
                            <h3
                                class="text-[10px] font-black text-white/40 uppercase tracking-[0.3em] border-l-2 border-rose-500 pl-3">
                                RGB Precision</h3>
                            <div class="space-y-4">
                                <div>
                                    <div class="slider-label"><span>Red</span><span id="r-val">0</span></div><input
                                        type="range" id="input-r" min="0" max="255" value="0">
                                </div>
                                <div>
                                    <div class="slider-label"><span>Green</span><span id="g-val">242</span></div><input
                                        type="range" id="input-g" min="0" max="255" value="242">
                                </div>
                                <div>
                                    <div class="slider-label"><span>Blue</span><span id="bl-val">255</span></div><input
                                        type="range" id="input-bl" min="0" max="255" value="255">
                                </div>
                            </div>
                        </div>
                    </div>
                    <div class="pt-6 border-t border-white/5 flex items-center gap-6">
                        <div id="current-preview"
                            class="w-20 h-20 rounded shadow-[0_0_30px_rgba(0,0,0,0.5)] border border-white/10 shrink-0"
                            style="background-color: #00f2ff;"></div>
                        <div class="flex-1 overflow-hidden">
                            <div class="text-[9px] font-bold text-slate-500 uppercase tracking-widest mb-1">Preview
                                (Editable HEX)</div>
                            <div
                                class="text-xl font-black text-white tracking-tight uppercase mb-3 border-b border-white/20 pb-1">
                                <input type="text" id="hex-input" value="#00f2ff" maxlength="7">
                            </div>
                            <button onclick="addColorFromSliders()"
                                class="w-full py-3 bg-white text-black text-[10px] font-black uppercase tracking-widest hover:bg-cyan-400 transition-all shadow-xl">Add
                                to Palette</button>
                        </div>
                    </div>
                </div>
                <div class="lg:col-span-5 glass p-8 flex flex-col">
                    <div class="flex justify-between items-center mb-8 border-b border-white/10 pb-4">
                        <h3 class="text-xs font-bold text-white uppercase tracking-widest">Components</h3>
                        <span id="pool-count" class="text-cyan-400 font-black">0/10</span>
                    </div>
                    <div id="selected-pool" class="grid grid-cols-5 gap-3 mb-8 min-h-[100px]"></div>

                    <div class="bg-white/5 p-4 border border-white/5 rounded-sm mb-6 flex items-center justify-between">
                        <div class="space-y-1">
                            <h4 class="text-[10px] font-black text-white uppercase tracking-widest">Challenge Mode</h4>
                            <p class="text-[8px] text-slate-500 leading-tight">20 turns limit / 2 rerolls per choice.
                            </p>
                        </div>
                        <label class="switch">
                            <input type="checkbox" id="game-mode-toggle">
                            <span class="slider-switch"></span>
                        </label>
                    </div>

                    <div class="space-y-6 mt-auto">
                        <div>
                            <h4 class="text-[9px] font-bold text-slate-600 uppercase tracking-widest mb-3">Color Presets
                            </h4>
                            <div class="grid grid-cols-3 gap-2">
                                <button onclick="applyPreset('BAUHAUS')"
                                    class="py-2 border border-white/5 hover:border-white/20 transition-all text-[8px] font-bold uppercase bg-white/5">Bauhaus</button>
                                <button onclick="applyPreset('CYBER')"
                                    class="py-2 border border-white/5 hover:border-white/20 transition-all text-[8px] font-bold uppercase bg-white/5">Cyber</button>
                                <button onclick="applyPreset('MONO')"
                                    class="py-2 border border-white/5 hover:border-white/20 transition-all text-[8px] font-bold uppercase bg-white/5">Mono</button>
                                <button onclick="applyPreset('SYNTH')"
                                    class="py-2 border border-white/5 hover:border-white/20 transition-all text-[8px] font-bold uppercase bg-white/5">Synth</button>
                                <button onclick="applyPreset('EARTH')"
                                    class="py-2 border border-white/5 hover:border-white/20 transition-all text-[8px] font-bold uppercase bg-white/5">Earth</button>
                                <button onclick="applyPreset('OCEAN')"
                                    class="py-2 border border-white/5 hover:border-white/20 transition-all text-[8px] font-bold uppercase bg-white/5">Ocean</button>
                            </div>
                        </div>
                        <div class="space-y-3 pt-6 border-t border-white/10">
                            <button id="start-btn" onclick="startStudio(false)" disabled
                                class="w-full py-5 bg-slate-800 text-slate-500 text-xs font-black uppercase tracking-[0.3em] cursor-not-allowed transition-all">Collect
                                Colors</button>
                            <button onclick="startStudio(true)"
                                class="w-full py-3 text-[9px] text-white/30 hover:text-white transition-all uppercase tracking-[0.4em] font-bold">All
                                Random Spectrum Mode</button>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- MAIN STUDIO SCREEN -->
    <div id="app"
        class="min-h-screen flex flex-col items-center p-4 md:p-10 opacity-0 transition-opacity duration-1000">
        <header
            class="w-full max-w-7xl flex flex-col lg:flex-row justify-between items-center mb-10 gap-8 border-b border-white/5 pb-10">
            <div class="text-center lg:text-left">
                <div class="flex items-center justify-center lg:justify-start gap-2 text-cyan-400 mb-2">
                    <i data-lucide="zap" class="w-4 h-4 animate-pulse"></i>
                    <span id="mode-label"
                        class="text-[10px] font-bold tracking-[0.6em] uppercase">Computational.Art.Studio.v13</span>
                </div>
                <h1 class="text-5xl md:text-7xl font-black italic tracking-tighter text-white uppercase leading-none">
                    Grid Alchemist</h1>
                <p id="palette-indicator"
                    class="text-[11px] text-slate-500 mt-4 font-bold tracking-[0.2em] uppercase italic">>>> Neural
                    Engine Optimized</p>
            </div>
            <div class="flex flex-wrap justify-center gap-3">
                <button id="blend-toggle" onclick="toggleBlendMode()"
                    class="px-6 py-3 border border-cyan-500/30 text-cyan-400 text-[10px] font-black uppercase tracking-[0.3em] hover:bg-cyan-500 hover:text-white transition-all glass flex items-center gap-2">
                    <i data-lucide="layers" class="w-4 h-4"></i> Blend: <span id="blend-status">OFF</span>
                </button>
                <div class="dropdown relative">
                    <button
                        class="px-6 py-3 bg-blue-600 text-white text-[10px] font-black uppercase tracking-[0.3em] hover:bg-blue-500 transition-all shadow-xl flex items-center gap-2">
                        <i data-lucide="download" class="w-4 h-4"></i> Export
                    </button>
                    <div
                        class="dropdown-menu absolute hidden right-0 mt-2 w-56 glass z-[100] shadow-2xl overflow-hidden">
                        <button onclick="exportImage('single')"
                            class="w-full text-left px-4 py-3 text-[10px] font-bold hover:bg-white/10 border-b border-white/5 text-slate-300">Original
                            (1x1)</button>
                        <button onclick="exportImage('radial')"
                            class="w-full text-left px-4 py-3 text-[10px] font-bold hover:bg-white/10 border-b border-white/5 text-cyan-400">Radial
                            Mandala (2x2)</button>
                        <button onclick="exportImage('repeat')"
                            class="w-full text-left px-4 py-3 text-[10px] font-bold hover:bg-white/10 border-b border-white/5 text-slate-300">Infinite
                            Tile (2x2)</button>
                    </div>
                </div>
                <button onclick="window.location.reload()"
                    class="px-6 py-3 border border-red-500/30 text-red-500 text-[10px] font-black uppercase tracking-[0.3em] hover:bg-red-500 hover:text-white transition-all glass">Reset
                    Lab</button>
            </div>
        </header>

        <main class="w-full max-w-7xl grid grid-cols-1 lg:grid-cols-12 gap-12 items-start">
            <div class="lg:col-span-7 xl:col-span-8 flex flex-col items-center">
                <div id="canvas-wrapper"
                    class="relative glass p-1 canvas-glow transition-all duration-500 overflow-hidden">
                    <div id="grid" class="grid-container"></div>
                    <div id="compiler-overlay"
                        class="absolute inset-0 bg-black/80 backdrop-blur-sm flex flex-col items-center justify-center z-50 opacity-0 pointer-events-none transition-opacity duration-300">
                        <i data-lucide="refresh-cw" class="w-12 h-12 text-white animate-spin mb-4"></i>
                        <span class="text-white text-[10px] font-black tracking-[1em]">RENDERING</span>
                    </div>
                    <div id="finish-overlay"
                        class="absolute inset-0 bg-black/90 backdrop-blur-md flex flex-col items-center justify-center z-[60] opacity-0 pointer-events-none transition-all duration-1000">
                        <i data-lucide="trophy" class="w-16 h-16 text-amber-500 mb-6"></i>
                        <h2 class="text-3xl font-black text-white uppercase tracking-[0.3em] mb-2 text-center">Creation
                            Finalized</h2>
                        <p class="text-xs text-slate-500 uppercase tracking-widest mb-10">Challenge Mode Accomplished.
                        </p>
                        <button onclick="exportImage('radial')"
                            class="px-10 py-4 bg-cyan-600 text-black text-xs font-black uppercase tracking-[0.5em] hover:bg-white transition-all">Export
                            Artwork</button>
                    </div>
                </div>
            </div>

            <div class="lg:col-span-5 xl:col-span-4 flex flex-col gap-8 w-full">
                <div id="game-stats" class="grid grid-cols-2 gap-4 hidden">
                    <div class="glass p-5 flex flex-col items-center">
                        <span class="text-[9px] font-bold text-slate-500 uppercase tracking-widest mb-1">Turns
                            Left</span>
                        <span id="turn-stat" class="text-3xl font-black text-white">20</span>
                    </div>
                    <div class="glass p-5 flex flex-col items-center">
                        <span class="text-[9px] font-bold text-slate-500 uppercase tracking-widest mb-1">Rerolls</span>
                        <span id="reroll-stat" class="text-3xl font-black text-cyan-400">2</span>
                    </div>
                </div>

                <div class="glass p-6 h-[200px] flex flex-col relative overflow-hidden">
                    <div class="absolute top-0 left-0 w-full h-1 bg-cyan-500/20"></div>
                    <h2
                        class="text-[10px] font-bold text-slate-500 uppercase tracking-widest mb-4 flex items-center gap-2">
                        <i data-lucide="terminal" class="w-4 h-4"></i> Protocol_Stream.log</h2>
                    <div id="history-log"
                        class="flex-1 overflow-y-auto space-y-2 custom-scrollbar pr-2 font-mono text-[10px]">
                        <div class="text-slate-800 italic uppercase">Initializing Workspace...</div>
                    </div>
                </div>

                <div class="space-y-4">
                    <div class="flex justify-between items-center border-b border-white/5 pb-3">
                        <h2 class="text-[10px] font-black text-white uppercase tracking-[0.4em]">Protocol Hand</h2>
                        <button id="reroll-btn" onclick="rerollHand()"
                            class="flex items-center gap-1.5 px-3 py-1.5 text-[9px] font-bold text-cyan-400 hover:text-white transition-colors border border-cyan-400/30 hover:bg-cyan-400/20 rounded-sm disabled:opacity-30 disabled:cursor-not-allowed">
                            <i data-lucide="refresh-ccw" class="w-3 h-3"></i> Reroll Hand
                        </button>
                    </div>
                    <div id="hand" class="flex flex-col gap-3"></div>
                    <div class="flex justify-between items-center px-1">
                        <div id="current-palette-display" class="flex gap-1 overflow-hidden"></div>
                        <span id="cycle-count" class="text-[9px] text-cyan-900 font-bold tracking-tighter shrink-0">CYC:
                            000</span>
                    </div>
                </div>
            </div>
        </main>
    </div>

    <canvas id="export-canvas" style="display:none;"></canvas>

    <script>
        const GRID_SIZE = 48;
        const TOTAL = GRID_SIZE * GRID_SIZE;
        const MID = GRID_SIZE / 2;
        let cells = [];
        let turnCount = 0;
        let isBlendMode = false;
        let colorPool = [];
        let allRandomMode = false;
        let currentSelectedColor = "#00f2ff";

        let isChallengeMode = false;
        let remainingTurns = 20;
        let remainingRerolls = 2;

        const PRESETS = {
            BAUHAUS: ['#E63946', '#F1FAEE', '#A8DADC', '#457B9D', '#1D3557', '#FFD166', '#06D6A0', '#118AB2', '#073B4C', '#FFFFFF'],
            CYBER: ['#00F2FF', '#0019FF', '#FB00FF', '#7000FF', '#00FF41', '#FF0000', '#FFFF00', '#222222', '#111111', '#FFFFFF'],
            MONO: ['#FFFFFF', '#F1F5F9', '#CBD5E1', '#94A3B8', '#64748B', '#475569', '#334155', '#1E293B', '#0F172A', '#020617'],
            SYNTH: ['#FF00FF', '#00FFFF', '#FFFF00', '#FF0055', '#7000FF', '#FF8A00', '#00FF41', '#FFD700', '#FFFFFF', '#000000'],
            EARTH: ['#264653', '#2A9D8F', '#E9C46A', '#F4A261', '#E76F51', '#8B5E3C', '#BC8F8F', '#DEB887', '#556B2F', '#FFFFFF'],
            OCEAN: ['#0077B6', '#00B4D8', '#90E0EF', '#03045E', '#023E8A', '#CAF0F8', '#48CAE4', '#0096C7', '#FFFFFF', '#111111']
        };

        function hsvToRgb(h, s, v) {
            h /= 360; s /= 100; v /= 100;
            let r, g, b, i = Math.floor(h * 6), f = h * 6 - i, p = v * (1 - s), q = v * (1 - f * s), t = v * (1 - (1 - f) * s);
            switch (i % 6) {
                case 0: r = v, g = t, b = p; break; case 1: r = q, g = v, b = p; break; case 2: r = p, g = v, b = t; break;
                case 3: r = p, g = q, b = v; break; case 4: r = t, g = p, b = v; break; case 5: r = v, g = p, b = q; break;
            }
            return [Math.round(r * 255), Math.round(g * 255), Math.round(b * 255)];
        }
        function rgbToHsv(r, g, b) {
            r /= 255, g /= 255, b /= 255;
            let max = Math.max(r, g, b), min = Math.min(r, g, b), h, s, v = max, d = max - min;
            s = max === 0 ? 0 : d / max;
            if (max === min) h = 0;
            else { switch (max) { case r: h = (g - b) / d + (g < b ? 6 : 0); break; case g: h = (b - r) / d + 2; break; case b: h = (r - g) / d + 4; break; } h /= 6; }
            return [Math.round(h * 360), Math.round(s * 100), Math.round(v * 100)];
        }
        function rgbToHex(r, g, b) { return "#" + [r, g, b].map(x => x.toString(16).padStart(2, '0')).join(''); }

        function hexToRgb(hex) {
            const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
            return result ? [parseInt(result[1], 16), parseInt(result[2], 16), parseInt(result[3], 16)] : null;
        }

        function initColorSliders() {
            const iH = document.getElementById('input-h'), iS = document.getElementById('input-s'), iB = document.getElementById('input-b');
            const iR = document.getElementById('input-r'), iG = document.getElementById('input-g'), iBl = document.getElementById('input-bl');
            const hexInput = document.getElementById('hex-input');

            function updateFh() { const [r, g, b] = hsvToRgb(iH.value, iS.value, iB.value); iR.value = r; iG.value = g; iBl.value = b; updateUI(); }
            function updateFr() { const [h, s, v] = rgbToHsv(iR.value, iG.value, iBl.value); iH.value = h; iS.value = s; iB.value = v; updateUI(); }

            function updateFromHex() {
                let val = hexInput.value;
                if (!val.startsWith('#')) val = '#' + val;
                const rgb = hexToRgb(val);
                if (rgb) {
                    iR.value = rgb[0]; iG.value = rgb[1]; iBl.value = rgb[2];
                    updateFr();
                }
            }

            function updateUI() {
                document.getElementById('r-val').innerText = iR.value; document.getElementById('g-val').innerText = iG.value; document.getElementById('bl-val').innerText = iBl.value;
                document.getElementById('h-val').innerText = iH.value + '°'; document.getElementById('s-val').innerText = iS.value + '%'; document.getElementById('b-val').innerText = iB.value + '%';
                currentSelectedColor = rgbToHex(parseInt(iR.value), parseInt(iG.value), parseInt(iBl.value));
                document.getElementById('current-preview').style.backgroundColor = currentSelectedColor;
                if (document.activeElement !== hexInput) {
                    hexInput.value = currentSelectedColor;
                }
            }

            iH.oninput = iS.oninput = iB.oninput = updateFh;
            iR.oninput = iG.oninput = iBl.oninput = updateFr;
            hexInput.oninput = updateFromHex;

            updateFh();
        }

        function addColorFromSliders() { if (colorPool.length < 10) { colorPool.push(currentSelectedColor); updatePoolUI(); } }
        function applyPreset(n) { colorPool = [...PRESETS[n]]; updatePoolUI(); }
        function updatePoolUI() {
            const poolEl = document.getElementById('selected-pool'); poolEl.innerHTML = '';
            for (let i = 0; i < 10; i++) {
                const slot = document.createElement('div'); slot.className = 'color-slot';
                if (colorPool[i]) { slot.style.backgroundColor = colorPool[i]; slot.onclick = () => { colorPool.splice(i, 1); updatePoolUI(); }; }
                poolEl.appendChild(slot);
            }
            document.getElementById('pool-count').innerText = `${colorPool.length}/10`;
            const btn = document.getElementById('start-btn');
            if (colorPool.length > 0) { btn.disabled = false; btn.className = 'w-full py-5 bg-cyan-500 text-black text-xs font-black uppercase tracking-[0.3em] hover:bg-white transition-all shadow-xl'; btn.innerText = `Launch with ${colorPool.length} Colors`; }
            else { btn.disabled = true; btn.className = 'w-full py-5 bg-slate-800 text-slate-500 text-xs font-black uppercase tracking-[0.3em] cursor-not-allowed'; btn.innerText = 'Select Colors'; }
        }

        function startStudio(allR) {
            allRandomMode = allR; isChallengeMode = document.getElementById('game-mode-toggle').checked;
            document.getElementById('setup-screen').classList.add('setup-hidden'); document.getElementById('app').classList.remove('opacity-0');
            if (isChallengeMode) { document.getElementById('game-stats').classList.remove('hidden'); document.getElementById('mode-label').innerText = "Challenge.Mode.Active"; }
            const cp = document.getElementById('current-palette-display'); cp.innerHTML = '';
            if (!allRandomMode) colorPool.forEach(c => { const d = document.createElement('div'); d.className = 'w-2 h-2 rounded-full'; d.style.backgroundColor = c; cp.appendChild(d); });
            initGrid(); rerollHand(); lucide.createIcons();
        }

        function getStudioColor() { return allRandomMode ? `hsl(${Math.floor(Math.random() * 360)}, 75%, 60%)` : colorPool[Math.floor(Math.random() * colorPool.length)]; }
        function mixColors(c1, c2) {
            if (!c1 || c1 === '#000' || c1 === 'rgb(0, 0, 0)') return c2;
            const d = document.createElement('canvas').getContext('2d'); d.fillStyle = c1; const r1 = d.fillStyle.match(/\d+/g).map(Number);
            d.fillStyle = c2; const r2 = d.fillStyle.match(/\d+/g).map(Number);
            return `rgb(${Math.round((r1[0] + r2[0] * 2) / 3)}, ${Math.round((r1[1] + r2[1] * 2) / 3)}, ${Math.round((r1[2] + r2[2] * 2) / 3)})`;
        }
        function toggleBlendMode() { isBlendMode = !isBlendMode; document.getElementById('blend-status').innerText = isBlendMode ? 'ON' : 'OFF'; document.getElementById('blend-toggle').classList.toggle('btn-active'); renderGrid(); }

        const CARD_TEMPLATES = [
            {
                name: 'STEP SAMPLER', type: 'Logic', icon: 'hash', create: () => {
                    const col = getStudioColor(); const n = Math.floor(Math.random() * 8) + 4;
                    return { color: col, desc: `${n}번째 데이터 슬롯마다 정밀하게 픽셀을 배치합니다.`, logic: (c) => c.map((x, i) => i % n === 0 ? { ...x, active: true, color: col } : x) };
                }
            },
            {
                name: 'MODULO MESH', type: 'Logic', icon: 'grid', create: () => {
                    const col = getStudioColor(); const m = Math.floor(Math.random() * 5) + 4;
                    return { color: col, desc: `${m}픽셀 주기로 기하학적 격자망을 형성합니다.`, logic: (c) => c.map(x => (x.x % m === 0 || x.y % m === 0) ? { ...x, active: true, color: col } : x) };
                }
            },
            {
                name: 'CONCENTRIC RINGS', type: 'Gen', icon: 'target', create: () => {
                    const col = getStudioColor(); const gap = 3 + Math.random() * 5;
                    return { color: col, desc: `${gap.toFixed(0)}픽셀 주기의 동심원 패턴을 중첩합니다.`, logic: (c) => c.map(x => (Math.floor(Math.sqrt((x.x - 23.5) ** 2 + (x.y - 23.5) ** 2)) % Math.floor(gap) === 0) ? { ...x, active: true, color: col } : x) };
                }
            },
            {
                name: 'STOCHASTIC NOISE', type: 'Gen', icon: 'sparkles', create: () => {
                    const col = getStudioColor(); const density = 0.05 + Math.random() * 0.15;
                    return { color: col, desc: `${(density * 100).toFixed(0)}% 확률로 픽셀 노이즈를 살포합니다.`, logic: (c) => c.map(x => Math.random() < density ? { ...x, active: true, color: col } : x) };
                }
            },
            {
                name: 'PALETTE SWAP', type: 'Data', icon: 'shuffle', create: () => ({
                    color: '#fff', desc: `픽셀들의 색상을 팔레트 내 다른 색으로 무작위 교체합니다.`, logic: (c) => {
                        if (allRandomMode || colorPool.length < 2) return c.map(x => x.active ? { ...x, color: getStudioColor() } : x);
                        const map = new Map(); const shuffled = [...colorPool].sort(() => Math.random() - 0.5);
                        colorPool.forEach((col, i) => map.set(col, shuffled[i]));
                        return c.map(x => x.active ? { ...x, color: map.get(x.color) || x.color } : x);
                    }
                })
            },
            {
                name: 'ANGULAR SYM', type: 'Spatial', icon: 'refresh-ccw', create: () => ({
                    color: '#fbbf24', desc: `중심 기반 4방향 회전 대칭 조형을 완성합니다.`, logic: (c) => {
                        const next = [...c]; for (let y = 0; y < 24; y++) for (let x = 0; x < 24; x++) {
                            const s = c[y * 48 + x]; if (!s.active) continue;
                            [[47 - x, y], [x, 47 - y], [47 - x, 47 - y]].forEach(([sx, sy]) => { next[sy * 48 + sx] = { ...s, x: sx, y: sy, active: true }; });
                        } return next;
                    }
                })
            },
            {
                name: 'KALEIDOSCOPE N', type: 'Spatial', icon: 'snowflake', create: () => {
                    const n = [6, 8, 12, 16][Math.floor(Math.random() * 4)];
                    return {
                        color: '#fbbf24', desc: `${n}분할 무작위 만화경 대칭으로 기하학적 미학을 극대화합니다.`, logic: (c) => {
                            const next = [...c]; const centerX = 23.5, centerY = 23.5;
                            const angleStep = (Math.PI * 2) / n;
                            c.forEach(p => {
                                if (!p.active) return;
                                const dx = p.x - centerX, dy = p.y - centerY;
                                const r = Math.sqrt(dx * dx + dy * dy);
                                const startAngle = Math.atan2(dy, dx);
                                for (let i = 1; i < n; i++) {
                                    const curAngle = startAngle + i * angleStep;
                                    const nx = Math.round(centerX + r * Math.cos(curAngle)), ny = Math.round(centerY + r * Math.sin(curAngle));
                                    if (nx >= 0 && nx < 48 && ny >= 0 && ny < 48) next[ny * 48 + nx] = { ...p, x: nx, y: ny };
                                }
                            }); return next;
                        }
                    };
                }
            },
            {
                name: 'RANDOM MIRROR', type: 'Spatial', icon: 'combine', create: () => {
                    const axis = Math.random() > 0.5 ? 'X' : 'Y'; const side = Math.random() > 0.5 ? 0 : 1;
                    return {
                        color: '#ec4899', desc: `무작위 축(${axis})을 기준으로 대칭 반사 시킵니다.`, logic: (c) => {
                            const next = [...c];
                            if (axis === 'X') { for (let y = 0; y < 48; y++) for (let x = 0; x < 24; x++) { const s = side ? c[y * 48 + (47 - x)] : c[y * 48 + x], tx = side ? x : 47 - x; next[y * 48 + tx] = { ...s, x: tx, y: y }; } }
                            else { for (let x = 0; x < 48; x++) for (let y = 0; y < 24; y++) { const s = side ? c[(47 - y) * 48 + x] : c[y * 48 + x], ty = side ? y : 47 - y; next[ty * 48 + x] = { ...s, x: x, y: ty }; } }
                            return next;
                        }
                    };
                }
            },
            {
                name: 'QUADRANT SYNC', type: 'Spatial', icon: 'layout-grid', create: () => {
                    const srcQ = Math.floor(Math.random() * 4);
                    return {
                        color: '#00f2ff', desc: `무작위 사분면(${srcQ + 1})을 전체 영역으로 패턴 복제합니다.`, logic: (c) => {
                            const next = [...c]; const xO = (srcQ % 2) * 24, yO = Math.floor(srcQ / 2) * 24;
                            for (let y = 0; y < 24; y++) for (let x = 0; x < 24; x++) {
                                const s = c[(y + yO) * 48 + (x + xO)]; for (let i = 0; i < 4; i++) { const tx = x + (i % 2) * 24, ty = y + Math.floor(i / 2) * 24; next[ty * 48 + tx] = { ...s, x: tx, y: ty }; }
                            } return next;
                        }
                    };
                }
            },
            {
                name: 'CIRCULAR CORE', type: 'Gen', icon: 'circle', create: () => {
                    const col = getStudioColor(); const r = 6 + Math.random() * 14, cx = 10 + Math.random() * 28, cy = 10 + Math.random() * 28;
                    return { color: col, desc: `반지름 ${r.toFixed(0)}의 원형 조형 데이터를 주입합니다.`, logic: (c) => c.map(x => (Math.sqrt((x.x - cx) ** 2 + (x.y - cy) ** 2) < r) ? { ...x, active: true, color: col } : x) };
                }
            },
            {
                name: 'TRIANGLE MESH', type: 'Gen', icon: 'triangle', create: () => {
                    const col = getStudioColor(); const pts = Array.from({ length: 3 }, () => ({ x: Math.random() * 48, y: Math.random() * 48 }));
                    return {
                        color: col, desc: `세 점을 잇는 삼각형 폴리곤 영역을 채색합니다.`, logic: (c) => {
                            const area = 0.5 * (-pts[1].y * pts[2].x + pts[0].y * (-pts[1].x + pts[2].x) + pts[0].x * (pts[1].y - pts[2].y) + pts[1].x * pts[2].y);
                            return c.map(pt => {
                                const s = 1 / (2 * area) * (pts[0].y * pts[2].x - pts[0].x * pts[2].y + (pts[2].y - pts[0].y) * pt.x + (pts[0].x - pts[2].x) * pt.y), t = 1 / (2 * area) * (pts[0].x * pts[1].y - pts[0].y * pts[1].x + (pts[0].y - pts[1].y) * pt.x + (pts[1].x - pts[0].x) * pt.y);
                                return (s > 0 && t > 0 && 1 - s - t > 0) ? { ...pt, active: true, color: col } : pt;
                            });
                        }
                    };
                }
            },
            {
                name: 'VECTOR DRIFT', type: 'Gravity', icon: 'wind', create: () => {
                    const d = ['UP', 'DOWN', 'LEFT', 'RIGHT'][Math.floor(Math.random() * 4)];
                    return {
                        color: '#10b981', desc: `${d} 방향 가속도로 데이터를 쏠리게 유도합니다.`, logic: (c) => {
                            const next = c.map(x => ({ ...x, active: false }));
                            if (d === 'DOWN') { for (let x = 0; x < 48; x++) { const acs = c.filter(p => p.x === x && p.active); acs.forEach((a, i) => { const ty = 47 - i; next[ty * 48 + x] = { ...a, y: ty, active: true }; }); } }
                            else if (d === 'UP') { for (let x = 0; x < 48; x++) { const acs = c.filter(p => p.x === x && p.active); acs.forEach((a, i) => { const ty = i; next[ty * 48 + x] = { ...a, y: ty, active: true }; }); } }
                            else if (d === 'RIGHT') { for (let y = 0; y < 48; y++) { const acs = c.filter(p => p.y === y && p.active); acs.forEach((a, i) => { const tx = 47 - i; next[y * 48 + tx] = { ...a, x: tx, active: true }; }); } }
                            else { for (let y = 0; y < 48; y++) { const acs = c.filter(p => p.y === y && p.active); acs.forEach((a, i) => { const tx = i; next[y * 48 + tx] = { ...a, x: tx, active: true }; }); } }
                            return next;
                        }
                    };
                }
            },
            {
                name: 'GRAVITY WELL', type: 'Gravity', icon: 'magnet', create: () => {
                    const cx = Math.floor(10 + Math.random() * 28), cy = Math.floor(10 + Math.random() * 28), pull = Math.random() > 0.3;
                    return {
                        color: '#fb7185', desc: `임의의 중심점으로 데이터를 ${pull ? '당깁니다' : '밉니다'}.`, logic: (c) => {
                            const next = c.map(x => ({ ...x, active: false }));
                            c.filter(p => p.active).forEach(p => {
                                let nx = p.x, ny = p.y;
                                if (pull) { if (nx < cx) nx++; else if (nx > cx) nx--; if (ny < cy) ny++; else if (ny > cy) ny--; }
                                else { if (nx < cx) nx--; else if (nx > cx) nx++; if (ny < cy) ny--; else if (ny > cy) ny++; }
                                nx = (nx + 48) % 48; ny = (ny + 48) % 48; next[ny * 48 + nx] = { ...p, x: nx, y: ny, active: true };
                            }); return next;
                        }
                    };
                }
            },
            {
                name: 'LIFE STEP', type: 'Life', icon: 'dna', create: () => ({
                    color: '#8b5cf6', desc: `생태계 진화 규칙을 적용하여 새로운 세대를 낳습니다.`, logic: (c) => c.map((x, i) => {
                        let n = 0, colors = []; for (let dy = -1; dy <= 1; dy++) for (let dx = -1; dx <= 1; dx++) { if (dx === 0 && dy === 0) continue; const nx = (x.x + dx + 48) % 48, ny = (x.y + dy + 48) % 48, nb = c[ny * 48 + nx]; if (nb.active) { n++; colors.push(nb.color); } }
                        const live = x.active ? (n === 2 || n === 3) : (n === 3);
                        let nCol = x.color; if (!x.active && live && colors.length > 0) nCol = colors[Math.floor(Math.random() * colors.length)];
                        return { ...x, active: live, color: nCol };
                    })
                })
            },
            {
                name: 'DIFFUSION', type: 'Warp', icon: 'expand', create: () => ({
                    color: '#a78bfa', desc: `활성 픽셀이 인접한 공간으로 유기적으로 번져나갑니다.`, logic: (c) => {
                        const next = [...c];
                        c.filter(p => p.active).forEach(p => {
                            if (Math.random() > 0.6) {
                                const nx = (p.x + (Math.floor(Math.random() * 3) - 1) + 48) % 48, ny = (p.y + (Math.floor(Math.random() * 3) - 1) + 48) % 48;
                                next[ny * 48 + nx] = { ...p, x: nx, y: ny, active: true };
                            }
                        });
                        return next;
                    }
                })
            },
            {
                name: 'GLITCH TEAR', type: 'Warp', icon: 'scissors', create: () => {
                    const sY = Math.floor(Math.random() * 48), o = Math.floor(Math.random() * 12) - 6;
                    return { color: '#ffffff', desc: `그리드 단면을 잘라 수평으로 오프셋 시킵니다.`, logic: (c) => c.map(x => (x.y > sY) ? { ...x, x: (x.x + o + 48) % 48 } : x) };
                }
            },
            {
                name: 'LIQUID WAVE', type: 'Warp', icon: 'waves', create: () => {
                    const a = 2 + Math.random() * 5;
                    return { color: '#00f2ff', desc: `사인 파동 왜곡으로 유동적인 질감을 만듭니다.`, logic: (c) => c.map(x => ({ ...x, x: (x.x + Math.floor(Math.sin(x.y * 0.2) * a) + 48) % 48 })) };
                }
            },
            {
                name: 'LUMA SORT', type: 'Data', icon: 'list-ordered', create: () => ({
                    color: '#f8fafc', desc: `명도 데이터 순으로 물리 정렬을 수행합니다.`, logic: (c) => {
                        const actives = c.filter(x => x.active).sort((a, b) => {
                            const getL = (col) => { const dc = document.createElement('canvas').getContext('2d'); dc.fillStyle = col; const m = dc.fillStyle.match(/\d+/g); return m ? (m[0] * 0.3 + m[1] * 0.59 + m[2] * 0.11) : 0; };
                            return getL(b.color) - getL(a.color);
                        });
                        const next = c.map(x => ({ ...x, active: false })); actives.forEach((ac, i) => { if (i < TOTAL) next[i] = { ...next[i], active: true, color: ac.color }; });
                        return next;
                    }
                })
            }
        ];

        function initGrid() { cells = []; for (let y = 0; y < 48; y++) for (let x = 0; x < 48; x++) cells.push({ x, y, active: false, color: '#000' }); renderGrid(); }
        function renderGrid() {
            const el = document.getElementById('grid'); el.innerHTML = ''; el.style.gridTemplateColumns = `repeat(48, 1fr)`;
            const s = Math.min(window.innerWidth * 0.92, 650); el.style.width = el.style.height = `${s}px`;
            const f = document.createDocumentFragment();
            cells.forEach(c => { const d = document.createElement('div'); d.className = 'pixel'; if (c.active) { d.style.backgroundColor = c.color; if (isBlendMode) d.style.opacity = "0.8"; } else d.style.backgroundColor = 'transparent'; f.appendChild(d); });
            el.appendChild(f);
        }

        function rerollHand() {
            if (isChallengeMode && remainingRerolls <= 0) return;
            if (isChallengeMode) remainingRerolls--;
            updateGameStats();
            const h = document.getElementById('hand'); h.innerHTML = '';
            for (let i = 0; i < 4; i++) {
                const t = CARD_TEMPLATES[Math.floor(Math.random() * CARD_TEMPLATES.length)];
                const inst = t.create(); const card = { ...t, ...inst, id: Math.random() };
                const btn = document.createElement('button'); btn.className = 'group relative flex items-center gap-4 p-4 glass hover:bg-white/5 transition-all text-left active:translate-y-1 rounded-sm overflow-hidden';
                btn.innerHTML = `<div class="w-10 h-10 rounded-sm flex items-center justify-center text-black shadow-lg group-hover:scale-110 transition-transform" style="background-color: ${card.color}"><i data-lucide="${card.icon}" class="w-5 h-5"></i></div><div class="flex-1 overflow-hidden"><div class="flex justify-between items-center mb-0.5"><span class="text-[8px] text-slate-600 uppercase font-black">${card.type}</span><h3 class="text-[11px] font-black text-white group-hover:text-cyan-400 uppercase truncate">${card.name}</h3></div><p class="text-[9px] text-slate-500 leading-tight truncate italic">${card.desc}</p></div><div class="absolute right-0 h-full w-1 opacity-0 group-hover:opacity-100 transition-opacity" style="background-color: ${card.color}"></div>`;
                btn.onclick = () => playCard(card); h.appendChild(btn);
            }
            lucide.createIcons();
        }

        function updateGameStats() {
            if (!isChallengeMode) return;
            document.getElementById('turn-stat').innerText = remainingTurns;
            document.getElementById('reroll-stat').innerText = remainingRerolls;
            document.getElementById('reroll-btn').disabled = remainingRerolls <= 0;
            if (remainingTurns <= 0) document.getElementById('finish-overlay').classList.remove('opacity-0', 'pointer-events-none');
        }

        async function playCard(card) {
            if (isChallengeMode && remainingTurns <= 0) return;
            const o = document.getElementById('compiler-overlay'); const w = document.getElementById('canvas-wrapper');
            o.classList.remove('opacity-0', 'pointer-events-none'); w.classList.add('compiling-active');
            await new Promise(r => setTimeout(r, 450));
            const nR = card.logic([...cells]);
            if (isBlendMode) cells = nR.map((nC, i) => { const oC = cells[i]; if (oC.active && nC.active && oC.color !== nC.color) return { ...nC, color: mixColors(oC.color, nC.color) }; return nC; });
            else cells = nR;
            turnCount++;
            if (isChallengeMode) { remainingTurns--; remainingRerolls = 2; }
            const l = document.getElementById('history-log'); if (l.querySelector('div.italic')) l.innerHTML = '';
            const e = document.createElement('div'); e.className = 'flex items-center gap-3 border-b border-white/5 pb-2 animate-in';
            e.innerHTML = `<span class="text-slate-700">[${turnCount}]</span> <span style="color: ${card.color}">${card.name}</span> <span class="ml-auto text-slate-600">DONE</span>`; l.prepend(e);
            document.getElementById('cycle-count').innerText = `CYC: ${turnCount.toString().padStart(3, '0')}`;
            updateGameStats(); renderGrid(); if (remainingTurns > 0 || !isChallengeMode) rerollHand();
            o.classList.add('opacity-0', 'pointer-events-none'); w.classList.remove('compiling-active');
        }

        function exportImage(mode) {
            const c = document.getElementById('export-canvas'), ctx = c.getContext('2d'), pS = 10, w = 48 * pS, h = 48 * pS;
            if (mode === 'single') { c.width = w; c.height = h; drawM(ctx, cells, 0, 0, pS, 0); }
            else {
                c.width = w * 2; c.height = h * 2; if (mode === 'repeat') [0, w].forEach(dx => [0, h].forEach(dy => drawM(ctx, cells, dx, dy, pS, 0))); else { drawM(ctx, cells, 0, 0, pS, 0); drawM(ctx, cells, w * 2, 0, pS, 90); drawM(ctx, cells, 0, h * 2, pS, 270); drawM(ctx, cells, w * 2, h * 2, pS, 180); }
            }
            const l = document.createElement('a'); l.download = `Alchemy_${mode}_${Date.now()}.png`; l.href = c.toDataURL('image/png'); l.click();
        }
        function drawM(ctx, d, ox, oy, ps, rot) { ctx.save(); ctx.translate(ox, oy); if (rot !== 0) ctx.rotate((rot * Math.PI) / 180); ctx.fillStyle = '#000'; ctx.fillRect(0, 0, 48 * ps, 48 * ps); d.forEach(c => { if (c.active) { ctx.fillStyle = c.color; if (isBlendMode) ctx.globalAlpha = 0.8; ctx.fillRect(c.x * ps, c.y * ps, ps, ps); ctx.globalAlpha = 1.0; } }); ctx.restore(); }

        window.addEventListener('resize', renderGrid);
        window.onload = () => { initColorSliders(); updatePoolUI(); lucide.createIcons(); };
    </script>

</body>

</html>